<div class="flex flex-col flex-1" 
     x-data="chatWidget()" 
     x-init="init()"
     @update-chat-patient.window="handlePatientSelect($event.detail)">
    
    <!-- 顶部标题栏 -->
    <div class="px-4 py-3 border-b border-slate-50 bg-slate-50/50 flex  flex-col">
        <div class="flex flex-col">
            <h3 class="font-semibold text-slate-700 text-sm">在线沟通</h3>
            <span class="text-xs text-slate-400" x-text="currentUserInfo"></span>
        </div>
        
        <!-- Tab 切换 (仅在选中患者后显示) -->
         <div class="flex justify-center items-center mt-1">
        <div class="flex bg-slate-200 p-0.5 rounded-lg" x-show="patientId" style="display: none;">
            <button @click="switchTab('patient')" 
                    :class="{'bg-white shadow text-slate-700': activeTab === 'patient', 'text-slate-500 hover:text-slate-600': activeTab !== 'patient'}"
                    class="px-3 py-1 text-xs font-medium rounded-md transition-all duration-200">
                <span x-text="patientName">患者</span>
            </button>
            <button @click="switchTab('internal')" 
                    :class="{'bg-white shadow text-slate-700': activeTab === 'internal', 'text-slate-500 hover:text-slate-600': activeTab !== 'internal'}"
                    class="px-3 py-1 text-xs font-medium rounded-md transition-all duration-200 ml-1">
                <span x-text="internalChatLabel">内部会话</span>
            </button>
        </div>
        </div>
    </div>

    <!-- 空状态 -->
    <div x-show="!patientId" class="flex-1 flex flex-col items-center justify-center text-slate-300 text-sm" data-test="empty-state">
        <svg class="w-12 h-12 mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
        </svg>
        请从左侧选择患者开始聊天
    </div>

    <!-- 聊天内容区域 -->
    <div x-show="patientId" class="flex-1 flex flex-col min-h-0" style="display: none;">
        
        <!-- 消息列表 -->
        <div class="flex-1 overflow-y-auto p-4 space-y-4" id="chat-messages-container" x-ref="messagesContainer">
            <template x-for="msg in messages" :key="msg.id">
                <div class="flex flex-col" :class="isMyMessage(msg) ? 'items-end' : 'items-start'">
                    <!-- 时间戳 (可选: 仅当时间间隔较大时显示) -->
                    <div class="text-xs text-slate-300 mb-1 text-center w-full" x-text="formatTime(msg.created_at)"></div>
                    
                    <div class="flex max-w-[85%]" :class="isMyMessage(msg) ? 'flex-row-reverse' : 'flex-row'">
                        <!-- 头像/名字 -->
                        <div class="flex-shrink-0 flex flex-col items-center mx-2">
                            <div class="w-8 h-8 rounded-full flex items-center justify-center text-xs font-bold text-white"
                                 :class="getAvatarColor(msg.sender_role)">
                                <span x-text="msg.sender_name.substring(0, 1)"></span>
                            </div>
                            <span class="text-[10px] text-slate-400 mt-1 max-w-[4rem] truncate" x-text="msg.sender_name"></span>
                        </div>

                        <!-- 消息气泡 -->
                        <div class="px-4 py-2 rounded-2xl text-sm shadow-sm relative group"
                             :class="isMyMessage(msg) ? 'bg-emerald-500 text-white rounded-tr-none' : 'bg-white text-slate-700 border border-slate-100 rounded-tl-none'">
                            
                            <!-- 文本内容 -->
                            <div x-show="msg.content_type === 1" class="whitespace-pre-wrap break-words" x-text="msg.text_content"></div>
                            
                            <!-- 图片内容 -->
                            <div x-show="msg.content_type === 2">
                                <img :src="msg.image_url" class="max-w-full rounded cursor-pointer" @click="window.open(msg.image_url, '_blank')">
                            </div>

                            <!-- 发送中状态 -->
                            <div x-show="msg.sending" class="absolute -left-6 top-1/2 -translate-y-1/2">
                                <svg class="animate-spin h-4 w-4 text-slate-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
            
            <div x-show="messages.length === 0 && !loading" class="text-center text-slate-300 text-sm py-8">
                暂无聊天记录
            </div>
        </div>

        <!-- 底部输入栏 -->
        <div class="p-3 border-t border-slate-100 bg-white">
            <div class="flex items-end gap-2 bg-slate-50 p-2 rounded-xl border border-slate-200 focus-within:border-emerald-400 focus-within:ring-1 focus-within:ring-emerald-400 transition-all">
                <textarea 
                    x-model="inputText" 
                    @keydown.enter.prevent="if(!$event.shiftKey) sendMessage()"
                    class="flex-1 bg-transparent border-none p-1 text-sm focus:ring-0 resize-none max-h-24 min-h-[24px]" 
                    rows="1" 
                    placeholder="输入消息..."
                    data-test="chat-input"></textarea>
                
                <!-- 工具栏 -->
                <div class="flex items-center gap-1 pb-0.5">
                    <button class="p-1.5 text-slate-400 hover:text-emerald-500 rounded-full hover:bg-slate-200 transition-colors" title="发送图片">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                        </svg>
                        <input type="file" class="hidden" accept="image/*" @change="uploadImage($event)">
                    </button>
                    
                    <button @click="sendMessage()" 
                            :disabled="!inputText.trim()"
                            class="p-1.5 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors shadow-sm"
                            data-test="send-btn">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function chatWidget() {
    return {
        patientId: null,
        patientName: '',
        activeTab: 'patient', // 'patient' or 'internal'
        internalChatLabel: '内部会话',
        messages: [],
        inputText: '',
        loading: false,
        pollInterval: null,
        currentUserInfo: '加载中...',
        currentUserId: {{ request.user.id }}, // Django 模板变量注入
        
        // 角色常量定义 (参考后端 choices)
        ROLES: {
            PATIENT: 1,
            FAMILY: 2,
            DIRECTOR: 3,
            PLATFORM_DOCTOR: 4,
            ASSISTANT: 5,
            CRC: 6
        },

        async init() {
            // 初始化时获取当前用户信息
            await this.fetchContext();
            
            // 监听图片上传按钮点击（通过 label 或 JS 触发 input 点击）
            // 上面的 input 已经绑定了 @change
        },

        async fetchContext(patientId = null) {
            try {
                let url = '/doctor/chat/api/context/';
                if (patientId) {
                    url += `?patient_id=${patientId}`;
                }
                const res = await fetch(url);
                const data = await res.json();
                if (data.status === 'success') {
                    const info = data.data;
                    this.currentUserInfo = `当前账号: ${info.user_name}(${info.role_label})`;
                    if (patientId) {
                        this.internalChatLabel = info.internal_label;
                    }
                }
            } catch (e) {
                console.error('获取上下文失败', e);
                // Fallback
                const userType = "{{ request.user.user_type }}";
                const userName = "{{ request.user.display_name }}";
                this.currentUserInfo = `当前账号: ${userName}`;
            }
        },

        handlePatientSelect(detail) {
            if (this.patientId === detail.id) return;
            
            this.patientId = detail.id;
            this.patientName = detail.name;
            this.activeTab = 'patient'; // 默认切回患者会话
            this.messages = [];
            
            // 获取新的上下文（包括动态的内部会话标签）
            this.fetchContext(this.patientId);
            
            this.loadMessages();
            this.startPolling();
        },

        switchTab(tab) {
            this.activeTab = tab;
            this.loadMessages();
        },

        async loadMessages() {
            if (!this.patientId) return;
            
            this.loading = true;
            try {
                // 1. 获取会话 ID (简化处理：先获取会话列表找到对应的 conversation_id)
                // 实际项目中后端接口应支持直接传 patient_id 获取或创建会话
                // 这里我们假设后端 list_conversations 返回了包含 conversation_id 的信息
                // 或者我们调用一个新接口。鉴于目前接口设计，我们先用 list_conversations 过滤
                
                // 优化：直接使用 list_messages 接口，但目前接口需要 conversation_id。
                // 临时方案：前端先调用 conversations 接口找到对应患者的 conversation_id
                // 长期方案：后端增加 get_conversation_by_patient 接口
                
                const convRes = await fetch(`/doctor/chat/api/conversations/`);
                const convData = await convRes.json();
                
                if (convData.status === 'success') {
                    const conv = convData.conversations.find(c => c.patient_id === this.patientId);
                    if (conv) {
                        this.currentConversationId = conv.conversation_id;
                        
                        // 加载消息
                        const msgRes = await fetch(`/doctor/chat/api/messages/list/?conversation_id=${this.currentConversationId}`);
                        const msgData = await msgRes.json();
                        
                        if (msgData.status === 'success') {
                            this.messages = msgData.messages;
                            this.scrollToBottom();
                            // 标记已读
                            this.markRead(this.currentConversationId, this.messages.length > 0 ? this.messages[this.messages.length-1].id : null);
                        }
                    } else {
                        // 还没有会话，显示空
                        this.messages = [];
                        this.currentConversationId = null; // 此时发送消息会失败，后端应提供 auto-create
                        // 如果后端 send 接口支持自动创建会话则更好，但目前看 send_text_message 需要 conversation_id
                        // 这是一个潜在的问题点。
                        // 修正：如果列表里没有，说明还没聊过。
                        // 医生端可能需要先"发起"会话？或者我们假设患者已经发起了。
                        // 根据需求，如果是空会话，医生发消息时可能需要先创建。
                        // 暂时先留空。
                    }
                }
            } catch (e) {
                console.error('加载消息失败', e);
            } finally {
                this.loading = false;
            }
        },

        async sendMessage() {
            const content = this.inputText.trim();
            if (!content || !this.patientId) return;

            // 乐观更新
            const tempMsg = {
                id: 'temp-' + Date.now(),
                sender_id: this.currentUserId,
                text_content: content,
                content_type: 1, // TEXT
                created_at: new Date().toISOString(),
                sender_name: '我',
                sender_role: this.ROLES.PLATFORM_DOCTOR, // 临时
                sending: true
            };
            this.messages.push(tempMsg);
            this.inputText = '';
            this.scrollToBottom();

            try {
                if (!this.currentConversationId) {
                    // 如果没有会话ID，可能需要后端支持通过 patient_id 发送，或者先创建
                    // 这里简化处理，提示错误
                    alert('会话未建立，无法发送');
                    this.messages.pop();
                    return;
                }

                const res = await fetch('/doctor/chat/api/messages/send/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({
                        conversation_id: this.currentConversationId,
                        content: content
                    })
                });
                const data = await res.json();
                
                if (data.status === 'success') {
                    // 替换临时消息
                    const index = this.messages.findIndex(m => m.id === tempMsg.id);
                    if (index !== -1) {
                        this.messages[index] = { ...tempMsg, ...data.message, sending: false };
                    }
                } else {
                    throw new Error(data.message);
                }
            } catch (e) {
                console.error('发送失败', e);
                this.messages.pop(); // 移除失败消息
                alert('发送失败: ' + e.message);
            }
        },

        startPolling() {
            if (this.pollInterval) clearInterval(this.pollInterval);
            this.pollInterval = setInterval(() => {
                if (this.currentConversationId) {
                    this.pollMessages();
                }
            }, 5000);
        },

        async pollMessages() {
            // 获取最新一条消息ID
            const lastId = this.messages.length > 0 ? this.messages[this.messages.length - 1].id : null;
            if (!lastId || String(lastId).startsWith('temp')) return; // 只有临时消息时不轮询增量

            try {
                const res = await fetch(`/doctor/chat/api/messages/list/?conversation_id=${this.currentConversationId}&after_id=${lastId}`);
                const data = await res.json();
                if (data.status === 'success' && data.messages.length > 0) {
                    // 过滤掉已存在的（以防万一）
                    const newMsgs = data.messages.filter(m => !this.messages.some(exist => exist.id === m.id));
                    if (newMsgs.length > 0) {
                        this.messages = [...this.messages, ...newMsgs];
                        this.scrollToBottom();
                        this.markRead(this.currentConversationId, newMsgs[newMsgs.length-1].id);
                    }
                }
            } catch (e) {
                console.error('轮询失败', e);
            }
        },
        
        async markRead(conversationId, lastMessageId) {
            if (!lastMessageId) return;
            try {
                await fetch('/doctor/chat/api/messages/read/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    },
                    body: JSON.stringify({
                        conversation_id: conversationId,
                        last_message_id: lastMessageId
                    })
                });
            } catch (e) {}
        },

        scrollToBottom() {
            this.$nextTick(() => {
                const container = this.$refs.messagesContainer;
                container.scrollTop = container.scrollHeight;
            });
        },

        isMyMessage(msg) {
            return msg.sender_id === this.currentUserId;
        },

        formatTime(isoString) {
            if (!isoString) return '';
            const date = new Date(isoString);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        },

        getAvatarColor(role) {
            // 根据角色返回背景色
            if (role === this.ROLES.PATIENT) return 'bg-blue-400';
            if (role === this.ROLES.FAMILY) return 'bg-indigo-400';
            if (role === this.ROLES.DIRECTOR) return 'bg-rose-500';
            return 'bg-emerald-500'; // 医生/助理
        },
        
        async uploadImage(event) {
             const file = event.target.files[0];
             if (!file) return;
             
             if (!this.currentConversationId) {
                 alert('会话未建立');
                 return;
             }
             
             const formData = new FormData();
             formData.append('conversation_id', this.currentConversationId);
             formData.append('image', file);
             formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
             
             // 乐观更新（略复杂，暂略）
             this.loading = true; // 简单loading
             
             try {
                 const res = await fetch('/doctor/chat/api/messages/upload/', {
                     method: 'POST',
                     body: formData
                 });
                 const data = await res.json();
                 if (data.status === 'success') {
                     this.messages.push({
                         ...data.message,
                         sender_id: this.currentUserId,
                         sender_name: '我',
                         content_type: 2
                     });
                     this.scrollToBottom();
                 } else {
                     alert(data.message);
                 }
             } catch(e) {
                 alert('上传失败');
             } finally {
                 this.loading = false;
                 event.target.value = ''; // 重置 input
             }
        }
    }
}
</script>

<!-- 
@Test Cases:
1. 空状态测试: 初始加载页面，应显示“请从左侧选择患者开始聊天”提示 (data-test="empty-state" visible)。
2. 患者选择测试: 模拟触发 update-chat-patient 事件，应隐藏空状态，显示聊天界面，且标题栏显示患者姓名。
3. 消息发送测试: 在输入框 (data-test="chat-input") 输入文本，点击发送 (data-test="send-btn")，应立即在列表显示新消息。
4. 角色区分测试: 检查消息列表，自己发送的消息应在右侧 (flex-row-reverse)，对方消息在左侧。
5. 异常处理测试: 断网情况下发送消息，应弹出 alert 提示失败，并移除临时消息。
-->
